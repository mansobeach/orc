#!/usr/bin/ruby

#########################################################################
##
## Ruby source for #CryptHelper class
##
## Written by DEIMOS Space S.L.
##
## Data Exchange Component -> Common Utils Component
## 
## git: $Id: CryptHelper.rb,v Exp $
##
#########################################################################

require 'openssl'
require 'base64'
require 'open3'

require 'cuc/Log4rLoggerFactory'

# https://wiki.openssl.org/index.php/Main_Page

# Module Common Utils Component
# This module provides helpers to encrypt / decrypt strings

## echo "Welcome to LinuxCareer.com" | openssl enc -base64
## echo "V2VsY29tZSB0byBMaW51eENhcmVlci5jb20K" | openssl enc -base64 -d

## use pass
## echo "U2FsdGVkX181xscMhkpIA6J0qd76N/nSjjTc9NrDUC0CBSLpZQxQ2Db7ipd7kexj" | openssl enc -aes-256-cbc -d -a

## use DEC
## echo "leiden1" | openssl enc -aes-256-cbc -a
## echo "leiden1" | openssl enc -rc4 -base64 -nosalt -a
# echo "sJhRW5wlxFs=" | openssl enc -rc4 -nosalt -d -a
# echo "U2FsdGVkX18ytn0VrDclhmrdQHhdlXAZ"  | openssl enc -rc4 -d -a

## echo "leiden1" | openssl enc -pbkdf2 -base64 -nosalt -a
## echo "bGVpZGVuMQo=" | openssl enc -pbkdf2 -nosalt -d -a

## echo "OpenSSL" | openssl enc -aes-256-cbc > openssl.dat
## openssl enc -aes-256-cbc -d -in openssl.dat

## echo "OpenSSL" | openssl enc -rc4 > openssl.dat
## openssl enc -rc4 -d -in openssl.dat

module CUC

module CryptHelper

   ## -------------------------------------------------------------  

   ## echo "leiden1" | openssl enc -pbkdf2 -base64 -nosalt -a
   ## echo "bGVpZGVuMQo=" | openssl enc -pbkdf2 -nosalt -d -a

   def cmdEncryptStr(plaintext, bIsDebug = false)
      cmd = "echo \"#{plaintext}\" | openssl enc -pbkdf2 -base64 -nosalt -a"
      
      if bIsDebug == true then
         puts cmd
      end

      str, status = Open3.capture2e(cmd)
      return str.chop      
   end

   ## -------------------------------------------------------------

   ## echo "leiden1" | openssl enc -pbkdf2 -base64 -nosalt -a
   ## echo "bGVpZGVuMQo=" | openssl enc -pbkdf2 -nosalt -d -a
   
   def cmdDecryptStr(cryptedtext, bIsDebug = false)
      cmd = "echo \"#{cryptedtext}\" | openssl enc -pbkdf2 -nosalt -d -a"
      
      if bIsDebug == true then
         puts cmd
      end

      str, status = Open3.capture2e(cmd)
      return str.chop            
   end
   ## -------------------------------------------------------------

   # echo -n "hola" | openssl enc -e -base64 -rc4 -nosalt -pass pass:secretkey -p
   # echo -n "oSW1ww==" | openssl enc -d -base64 -rc4 -nosalt -pass pass:secretkey -p

   def cmdEncrypt(plaintext, password, bIsDebug = false)
      cmd = "echo \"#{plaintext}\" | openssl enc -e -base64 -rc4 -nosalt -pass pass:#{password}"

      if bIsDebug == true then
         puts cmd
      end

      str, status = Open3.capture2e(cmd)
      return str.chop
   end
   ## -------------------------------------------------------------

   # echo -n "hola" | openssl enc -d -base64 -rc4 -nosalt -pass pass:secretkey

   def cmdDecrypt(plaintext, password, bIsDebug = false)
      cmd = "echo \"#{plaintext}\" | openssl enc -d -base64 -rc4 -nosalt -pass pass:#{password}"
      if bIsDebug == true then
         puts cmd
      end
      str = `#{cmd}`
      return str.chop
   end
   ## -------------------------------------------------------------   
   ## echo -n "hola" | openssl enc -e -base64 -rc4 -nosalt -pass pass:secretkey -p
   ##
   def encrypt(plaintext, key)
      cipher = OpenSSL::Cipher.new('rc4')
      cipher.encrypt
      # Use the key that was generated by EVP_BytesToKey
      # key = '610A2EE688CDA9E724885E23CD2CFDEE'
      # Convert the key to a byte string
      key_bytes   = key.scan(/../).map { |x| x.hex.chr }.join
      cipher.key  = key_bytes
      ciphertext  = cipher.update(plaintext) + cipher.final
      base64 = Base64.strict_encode64(ciphertext)
   end
   ## -------------------------------------------------------------

   ## echo "ryW2" | openssl enc -d -base64 -rc4 -nosalt -pass pass:secretkey
   ## 
   def decrypt(encrypted64, key)
      encryptedtext  = Base64.decode64(encrypted64)
      decipher       = OpenSSL::Cipher.new('rc4')
      decipher.decrypt
      key_bytes      = key.scan(/../).map { |x| x.hex.chr }.join
      decipher.key   = key_bytes
      decrypted      = decipher.update(encryptedtext) + decipher.final
   end
   ## -------------------------------------------------------------

   def encrypt_md5(plaintext, key)
      cipher = OpenSSL::Cipher.new('RC4')
      cipher.key = OpenSSL::Digest.digest('md5', key)
      cipher.decrypt
      Base64.encode64(cipher.update(plaintext) + cipher.final)
   end
   ## -----------------------------------------------------------
   ##
   ## 
   def decrypt_md5(encryptedtext, key)
      decipher = OpenSSL::Cipher.new('RC4')
      decipher.key = OpenSSL::Digest.digest('md5', key)
      decipher.decrypt
      decipher.update(Base64.decode64(encryptedtext)) + decipher.final
   end
   ## -------------------------------------------------------------

   def getChi(strProject)
      if strProject.downcase == 'dec' then
         return '000000000000000000000000$DEC2020'
         #return Base64.encode64('000000000000000000000000$DEC2020')
      end

      raise "encryption reference not found or supported"
   end
   ## -----------------------------------------------------------
   
   def getMagikGuord(strProject)
      if strProject.downcase == 'dec' then
         return '$DEC2020$'
      end

      raise "encryption reference not found or supported"
   end
   ## -----------------------------------------------------------

end # module

end # module
